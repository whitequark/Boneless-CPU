\documentclass[12pt,a4paper]{article}
\usepackage[hmargin=3cm,vmargin=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{import}
\usepackage{parskip}
\usepackage{color}
\usepackage[color,leftbars]{changebar}
\usepackage{ragged2e}
\usepackage{changepage}
\usepackage{alltt}
\renewcommand{\ttdefault}{txtt}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  pdfstartview=Fit,
  pdfpagemode=UseOutlines,
}

\newcommand{\undefined}{\textbf{UNDEFINED}}
\newcommand{\unpredictable}{\textbf{UNPREDICTABLE}}
\uchyph=0

\newenvironment{notice}{
  \cbcolor{red}
  \par\textbf{Notice:}\cbstart\par
  \begin{adjustwidth}{10pt}{0pt}
}{
  \end{adjustwidth}
  \cbend
}

\begin{document}

\begin{titlepage}
  \centering
  \vspace*{6cm}
  \par{\Huge Boneless-III}
  \vspace{1cm}
  \par{\Huge Architecture Reference Manual}
\end{titlepage}

\begin{notice}
This document is a work in progress and subject to change without warning. However, the parts that are \textit{especially} subject to change carry a notice similar to this one.
\end{notice}

\pagebreak

\tableofcontents
\addcontentsline{toc}{section}{Table of Contents}
\pagebreak

\setcounter{tocdepth}{2}

\section{Introduction}
TBD
\pagebreak

\section{Guide to Instruction Set}
\newcommand{\ginsnref}[1]{\hyperref[insn:#1]{\texttt{#1}}}
\def←{$\leftarrow$}

This guide first explains how to interpret the notation used in this document. After, it explains the available registers and their behavior.

\subsection{Operation Syntax}
This document uses the following syntax and operators to describe the operation of each instruction.

\subsubsection{Undefined and Unpredictable Behavior}
To describe the boundaries of legal program behavior, this document uses the words \undefined{} and \unpredictable{}.

When execution encounters \unpredictable{} behavior, the implementation may perform any behavior, including but not limited to hanging and failing to continue execution. The resulting behavior may be different between executions even under the same circumstances.

Certain operations, including any operation with an \undefined{} input, will produce an \undefined{} result. Reading a register whose value is currently \undefined{} may produce any bit pattern. Multiple consecutive reads of such a register may also produce different bit patterns on each read.

\subsubsection{Reference Operators}
The following operators reference parts of variables or the attached memory.

\begin{itemize}
  \item \texttt{opB} ← \texttt{opA}: Store \texttt{opA} into \texttt{opB}. If necessary, \texttt{opA} is implicitly zero-extended or truncated to match the length of \texttt{opB}.
  \item \texttt{op[b:a]}: Reference bits \texttt{a} through \texttt{b}, inclusive, of \texttt{op}.
  \item \texttt{mem[addr]}: Reference memory word at word address \texttt{addr}. The address is implicitly ANDed with \texttt{0xFFFF}.
  \item \texttt{ext[addr]}: Reference external bus word at word address \texttt{addr}. The address is implicitly ANDed with \texttt{0xFFFF}.
  \item \texttt{\string{opA, opB\string}}: Concatenate the bits of \texttt{opA} and \texttt{opB}. \texttt{opA} makes the high-order bits of the result and \texttt{opB} makes the low-order bits.
  \item \texttt{opB\string{opA\string}}: Construct the result by repeating \texttt{opA} \texttt{opB} times.
\end{itemize}

\subsubsection{Arithmetic Operators}
The arithmetic operators perform arithmetic or bitwise logic between the operands. All operands to these operators are unsigned. If one operand is shorter than the other, it is zero-extended to match the length of the other.

\begin{itemize}
  \item \texttt{opA + opB}: Add \texttt{opA} and \texttt{opB}. The high bit of the result is a carry bit.
  \item \texttt{opA \textbf{and} opB}: Perform a bitwise AND between \texttt{opA} and \texttt{opB}.
  \item \texttt{opA \textbf{or} opB}: Perform a bitwise OR between \texttt{opA} and \texttt{opB}.
  \item \texttt{opA \textbf{xor} opB}: Perform a bitwise XOR between \texttt{opA} and \texttt{opB}.
  \item \texttt{\textbf{not} op}: Perform a bitwise negation of \texttt{op}.
\end{itemize}

\subsubsection{Logical Operators}
The logical operators yield 1 if the condition is satisfied and 0 if it is not. If one operand is shorter than the other, it is zero-extended to match the length of the other.

\begin{itemize}
  \item \texttt{opA = opB}: Satisfied if \texttt{opA} equals \texttt{opB}.
  \item \texttt{opA <> opB}: Satisfied if \texttt{opA} does not equal \texttt{opB}.
\end{itemize}

\subsubsection{Functions}

\begin{itemize}
  \item \texttt{sign\_extend\_16(op)}: Perform a sign extension of \texttt{op} by replicating the high bit until the total length is 16 bits.
  \item \texttt{decode\_imm\_al(op)}: Calculate the immediate value of an arithmetic or logical instruction according to the following table.\linebreak
    \begin{tabular}{|c c|}
    \hline
    \texttt{op} & Result \\
    \hline
    0 & \texttt{0x0000} \\
    1 & \texttt{0x0001} \\
    2 & \texttt{0x8000} \\
    3 & \texttt{TBD} \\
    4 & \texttt{0x00FF} \\
    5 & \texttt{0xFF00} \\
    6 & \texttt{0x7FFF} \\
    7 & \texttt{0xFFFF} \\
    \hline
    \end{tabular}
  \item \texttt{decode\_imm\_sr(op)}: Calculate the immediate value of a shift or rotate instruction according to the following table.\linebreak
    \begin{tabular}{|c c|}
    \hline
    \texttt{op} & Result \\
    \hline
    0 & 8 \\
    1 & 1 \\
    2 & 2 \\
    3 & 3 \\
    4 & 4 \\
    5 & 5 \\
    6 & 6 \\
    7 & 7 \\
    \hline
    \end{tabular}
\end{itemize}

\subsection{Registers}
The CPU contains a number of registers that are used to store data, computation results, and system state. The registers are operated on as described by the operation of each instruction. If a register is not modified by an instruction, its value is preserved, except where noted in this register definition.

\subsubsection{Program Counter}
The CPU features a 16-bit program counter named \texttt{PC}. All instructions are 16 bit, so all values of \texttt{PC} are valid.

Unless otherwise specified by an instruction's operation, \texttt{PC ← PC+1} after each instruction.

The behavior of \texttt{PC ← op} defines that \texttt{op} is truncated to 16 bits to fit \texttt{PC}. Thus, adjusting \texttt{PC} is defined to wrap.

At reset, \texttt{PC ← 0x0000}, but this value can be changed by the implementation.

\subsubsection{General Purpose Registers and the Window}
The CPU has eight 16-bit general purpose (GP) integer registers, named \texttt{R0} through \texttt{R7}. They are fully interchangeable and can be used as source and/or destination for any instruction which uses a GP register. The register file is windowed: register values are stored in main memory, starting at the window address.

The current window address is stored in a 16-bit register named \texttt{W}. Its value can only be set and/or read by the four window instructions: \ginsnref{ADJW}, \ginsnref{LDW}, \ginsnref{STW}, and \ginsnref{XCHW}. Setting \texttt{W} logically changes the values of all GP registers simultaneously, enabling fast procedure calls and task switches.

\texttt{W} is added to the number of a GP register to calculate the address where that register is stored. For example, the operation \texttt{mem[W+3] ← mem[W+1]} sets \texttt{R3} equal to \texttt{R1}.

The behavior of \texttt{W ← op} and \texttt{mem[op]} defines that \texttt{op} is truncated to 16 bits to fit \texttt{W}. Thus, adjusting \texttt{W} and calculating GP register addresses are defined to wrap.

At reset, \texttt{W ← 0xFFF8}, but this value can be changed by the implementation.

\subsubsection{Result Flags}
The CPU has four result flags to describe the result of ALU computations. The flags are updated by most ALU instructions. The CPU can act on the result of the flags by executing a conditional jump which transfers control if the flags are in the desired state. The exact contents of each flag after an instruction executes are explained in the instruction's operation, but the general purpose and behavior of each flag are explained below.

The \texttt{Z} (Zero) flag is set to 1 if the low 16 bits of the result of the operation were zero, and 0 otherwise.

The \texttt{S} (negative) flag is set to the 15th bit of the result of the operation.

The \texttt{C} (Carry) flag is set to the 16th bit of the result of an arithmetic operation, or \undefined{} if the operation was logical.

The \texttt{V} (oVerflow) flag is set if the arithmetic operation encountered two's complement overflow, or \undefined{} if the operation was logical.

\subsubsection{Extended Immediate}
The CPU has two registers that help build a 16-bit immediate value.

The \ginsnref{EXTI} instruction sets the \texttt{ext13} register to its 13-bit immediate and the \texttt{has\_ext13} register to 1.

Generally, if an instruction can use an immediate and \texttt{has\_ext13} is 1, the instruction will use \texttt{ext13} as the high 13 bits of the the immediate value and take the low 3 bits from the instruction itself. The exact behavior of an instruction with regards to \texttt{has\_ext13} and \texttt{ext13} is specified in the instruction's operation.

Except for after \ginsnref{EXTI}, \texttt{ext13 ← \undefined{}} and \texttt{has\_ext13 ← 0} after every instruction, even those which do not use either register.

\pagebreak

\section{List of Instructions}
The following pages provide a detailed description of instructions, arranged in alphabetical order.

Executing any instruction with an encoding not present on the following pages has \unpredictable{} behavior.
\pagebreak

\import{insns/}{index.tex}

\section{List of Assembly Directives}
TBD
\pagebreak

\section{Function Calling Sequence}
TBD
\pagebreak

\end{document}
